import "./chunk-5WWUZCGV.js";

// node_modules/numbro/dist/es/numbro.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var enUS;
var hasRequiredEnUS;
function requireEnUS() {
  if (hasRequiredEnUS)
    return enUS;
  hasRequiredEnUS = 1;
  enUS = {
    languageTag: "en-US",
    delimiters: {
      thousands: ",",
      decimal: "."
    },
    abbreviations: {
      thousand: "k",
      million: "m",
      billion: "b",
      trillion: "t"
    },
    spaceSeparated: false,
    ordinal: function(number) {
      let b = number % 10;
      return ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    },
    bytes: {
      binarySuffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"],
      decimalSuffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    },
    currency: {
      symbol: "$",
      position: "prefix",
      code: "USD"
    },
    currencyFormat: {
      thousandSeparated: true,
      totalLength: 4,
      spaceSeparated: true,
      spaceSeparatedCurrency: true
    },
    formats: {
      fourDigits: {
        totalLength: 4,
        spaceSeparated: true
      },
      fullWithTwoDecimals: {
        output: "currency",
        thousandSeparated: true,
        mantissa: 2
      },
      fullWithTwoDecimalsNoCurrency: {
        thousandSeparated: true,
        mantissa: 2
      },
      fullWithNoDecimals: {
        output: "currency",
        thousandSeparated: true,
        mantissa: 0
      }
    }
  };
  return enUS;
}
var unformatting;
var hasRequiredUnformatting;
function requireUnformatting() {
  if (hasRequiredUnformatting)
    return unformatting;
  hasRequiredUnformatting = 1;
  const allSuffixes = [
    { key: "ZiB", factor: Math.pow(1024, 7) },
    { key: "ZB", factor: Math.pow(1e3, 7) },
    { key: "YiB", factor: Math.pow(1024, 8) },
    { key: "YB", factor: Math.pow(1e3, 8) },
    { key: "TiB", factor: Math.pow(1024, 4) },
    { key: "TB", factor: Math.pow(1e3, 4) },
    { key: "PiB", factor: Math.pow(1024, 5) },
    { key: "PB", factor: Math.pow(1e3, 5) },
    { key: "MiB", factor: Math.pow(1024, 2) },
    { key: "MB", factor: Math.pow(1e3, 2) },
    { key: "KiB", factor: Math.pow(1024, 1) },
    { key: "KB", factor: Math.pow(1e3, 1) },
    { key: "GiB", factor: Math.pow(1024, 3) },
    { key: "GB", factor: Math.pow(1e3, 3) },
    { key: "EiB", factor: Math.pow(1024, 6) },
    { key: "EB", factor: Math.pow(1e3, 6) },
    { key: "B", factor: 1 }
  ];
  function escapeRegExp(s) {
    return s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function computeUnformattedValue(inputString, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations, format2) {
    if (!isNaN(+inputString)) {
      return +inputString;
    }
    let stripped = "";
    let newInput = inputString.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
    if (newInput !== inputString) {
      return -1 * computeUnformattedValue(newInput, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations);
    }
    for (let i = 0; i < allSuffixes.length; i++) {
      let suffix = allSuffixes[i];
      stripped = inputString.replace(RegExp(`([0-9 ])(${suffix.key})$`), "$1");
      if (stripped !== inputString) {
        return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations) * suffix.factor;
      }
    }
    stripped = inputString.replace("%", "");
    if (stripped !== inputString) {
      return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations) / 100;
    }
    let possibleOrdinalValue = parseFloat(inputString);
    if (isNaN(possibleOrdinalValue)) {
      return void 0;
    }
    let ordinalString = ordinal(possibleOrdinalValue);
    if (ordinalString && ordinalString !== ".") {
      stripped = inputString.replace(new RegExp(`${escapeRegExp(ordinalString)}$`), "");
      if (stripped !== inputString) {
        return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations);
      }
    }
    let inversedAbbreviations = {};
    Object.keys(abbreviations).forEach((key) => {
      inversedAbbreviations[abbreviations[key]] = key;
    });
    let abbreviationValues = Object.keys(inversedAbbreviations).sort().reverse();
    let numberOfAbbreviations = abbreviationValues.length;
    for (let i = 0; i < numberOfAbbreviations; i++) {
      let value = abbreviationValues[i];
      let key = inversedAbbreviations[value];
      stripped = inputString.replace(value, "");
      if (stripped !== inputString) {
        let factor = void 0;
        switch (key) {
          case "thousand":
            factor = Math.pow(10, 3);
            break;
          case "million":
            factor = Math.pow(10, 6);
            break;
          case "billion":
            factor = Math.pow(10, 9);
            break;
          case "trillion":
            factor = Math.pow(10, 12);
            break;
        }
        return computeUnformattedValue(stripped, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations) * factor;
      }
    }
    return void 0;
  }
  function removeFormattingSymbols(inputString, delimiters, currencySymbol) {
    let stripped = inputString.replace(currencySymbol, "");
    stripped = stripped.replace(new RegExp(`([0-9])${escapeRegExp(delimiters.thousands)}([0-9])`, "g"), "$1$2");
    stripped = stripped.replace(delimiters.decimal, ".");
    return stripped;
  }
  function unformatValue(inputString, delimiters, currencySymbol = "", ordinal, zeroFormat, abbreviations, format2) {
    if (inputString === "") {
      return void 0;
    }
    if (inputString === zeroFormat) {
      return 0;
    }
    let value = removeFormattingSymbols(inputString, delimiters, currencySymbol);
    return computeUnformattedValue(value, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations);
  }
  function matchesTime(inputString, delimiters) {
    let separators = inputString.indexOf(":") && delimiters.thousands !== ":";
    if (!separators) {
      return false;
    }
    let segments = inputString.split(":");
    if (segments.length !== 3) {
      return false;
    }
    let hours = +segments[0];
    let minutes = +segments[1];
    let seconds = +segments[2];
    return !isNaN(hours) && !isNaN(minutes) && !isNaN(seconds);
  }
  function unformatTime(inputString) {
    let segments = inputString.split(":");
    let hours = +segments[0];
    let minutes = +segments[1];
    let seconds = +segments[2];
    return seconds + 60 * minutes + 3600 * hours;
  }
  function unformat(inputString, format2) {
    const globalState2 = requireGlobalState();
    let delimiters = globalState2.currentDelimiters();
    let currencySymbol = globalState2.currentCurrency().symbol;
    let ordinal = globalState2.currentOrdinal();
    let zeroFormat = globalState2.getZeroFormat();
    let abbreviations = globalState2.currentAbbreviations();
    let value = void 0;
    if (typeof inputString === "string") {
      if (matchesTime(inputString, delimiters)) {
        value = unformatTime(inputString);
      } else {
        value = unformatValue(inputString, delimiters, currencySymbol, ordinal, zeroFormat, abbreviations);
      }
    } else if (typeof inputString === "number") {
      value = inputString;
    } else {
      return void 0;
    }
    if (value === void 0) {
      return void 0;
    }
    return value;
  }
  unformatting = {
    unformat
  };
  return unformatting;
}
var validating$1;
var hasRequiredValidating;
function requireValidating() {
  if (hasRequiredValidating)
    return validating$1;
  hasRequiredValidating = 1;
  let unformatter2 = requireUnformatting();
  const bcp47RegExp = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/;
  const validOutputValues = [
    "currency",
    "percent",
    "byte",
    "time",
    "ordinal",
    "number"
  ];
  const validForceAverageValues = [
    "trillion",
    "billion",
    "million",
    "thousand"
  ];
  const validCurrencyPosition = [
    "prefix",
    "infix",
    "postfix"
  ];
  const validNegativeValues = [
    "sign",
    "parenthesis"
  ];
  const validMandatoryAbbreviations = {
    type: "object",
    children: {
      thousand: {
        type: "string",
        mandatory: true
      },
      million: {
        type: "string",
        mandatory: true
      },
      billion: {
        type: "string",
        mandatory: true
      },
      trillion: {
        type: "string",
        mandatory: true
      }
    },
    mandatory: true
  };
  const validAbbreviations = {
    type: "object",
    children: {
      thousand: "string",
      million: "string",
      billion: "string",
      trillion: "string"
    }
  };
  const validBaseValues = [
    "decimal",
    "binary",
    "general"
  ];
  const validFormat = {
    output: {
      type: "string",
      validValues: validOutputValues
    },
    base: {
      type: "string",
      validValues: validBaseValues,
      restriction: (number, format2) => format2.output === "byte",
      message: "`base` must be provided only when the output is `byte`",
      mandatory: (format2) => format2.output === "byte"
    },
    characteristic: {
      type: "number",
      restriction: (number) => number >= 0,
      message: "value must be positive"
    },
    prefix: "string",
    postfix: "string",
    forceAverage: {
      type: "string",
      validValues: validForceAverageValues
    },
    average: "boolean",
    lowPrecision: {
      type: "boolean",
      restriction: (number, format2) => format2.average === true,
      message: "`lowPrecision` must be provided only when the option `average` is set"
    },
    currencyPosition: {
      type: "string",
      validValues: validCurrencyPosition
    },
    currencySymbol: "string",
    totalLength: {
      type: "number",
      restrictions: [
        {
          restriction: (number) => number >= 0,
          message: "value must be positive"
        },
        {
          restriction: (number, format2) => !format2.exponential,
          message: "`totalLength` is incompatible with `exponential`"
        }
      ]
    },
    mantissa: {
      type: "number",
      restriction: (number) => number >= 0,
      message: "value must be positive"
    },
    optionalMantissa: "boolean",
    trimMantissa: "boolean",
    roundingFunction: "function",
    optionalCharacteristic: "boolean",
    thousandSeparated: "boolean",
    spaceSeparated: "boolean",
    spaceSeparatedCurrency: "boolean",
    spaceSeparatedAbbreviation: "boolean",
    abbreviations: validAbbreviations,
    negative: {
      type: "string",
      validValues: validNegativeValues
    },
    forceSign: "boolean",
    exponential: {
      type: "boolean"
    },
    prefixSymbol: {
      type: "boolean",
      restriction: (number, format2) => format2.output === "percent",
      message: "`prefixSymbol` can be provided only when the output is `percent`"
    }
  };
  const validLanguage = {
    languageTag: {
      type: "string",
      mandatory: true,
      restriction: (tag) => {
        return tag.match(bcp47RegExp);
      },
      message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)"
    },
    delimiters: {
      type: "object",
      children: {
        thousands: "string",
        decimal: "string",
        thousandsSize: "number"
      },
      mandatory: true
    },
    abbreviations: validMandatoryAbbreviations,
    spaceSeparated: "boolean",
    spaceSeparatedCurrency: "boolean",
    ordinal: {
      type: "function",
      mandatory: true
    },
    bytes: {
      type: "object",
      children: {
        binarySuffixes: "object",
        decimalSuffixes: "object"
      }
    },
    currency: {
      type: "object",
      children: {
        symbol: "string",
        position: "string",
        code: "string"
      },
      mandatory: true
    },
    defaults: "format",
    ordinalFormat: "format",
    byteFormat: "format",
    percentageFormat: "format",
    currencyFormat: "format",
    timeDefaults: "format",
    formats: {
      type: "object",
      children: {
        fourDigits: {
          type: "format",
          mandatory: true
        },
        fullWithTwoDecimals: {
          type: "format",
          mandatory: true
        },
        fullWithTwoDecimalsNoCurrency: {
          type: "format",
          mandatory: true
        },
        fullWithNoDecimals: {
          type: "format",
          mandatory: true
        }
      }
    }
  };
  function validate(input, format2) {
    let validInput = validateInput(input);
    let isFormatValid = validateFormat(format2);
    return validInput && isFormatValid;
  }
  function validateInput(input) {
    let value = unformatter2.unformat(input);
    return value !== void 0;
  }
  function validateSpec(toValidate, spec, prefix, skipMandatoryCheck = false) {
    let results = Object.keys(toValidate).map((key) => {
      if (!spec[key]) {
        console.error(`${prefix} Invalid key: ${key}`);
        return false;
      }
      let value = toValidate[key];
      let data = spec[key];
      if (typeof data === "string") {
        data = { type: data };
      }
      if (data.type === "format") {
        let valid = validateSpec(value, validFormat, `[Validate ${key}]`, true);
        if (!valid) {
          return false;
        }
      } else if (typeof value !== data.type) {
        console.error(`${prefix} ${key} type mismatched: "${data.type}" expected, "${typeof value}" provided`);
        return false;
      }
      if (data.restrictions && data.restrictions.length) {
        let length = data.restrictions.length;
        for (let i = 0; i < length; i++) {
          let { restriction, message } = data.restrictions[i];
          if (!restriction(value, toValidate)) {
            console.error(`${prefix} ${key} invalid value: ${message}`);
            return false;
          }
        }
      }
      if (data.restriction && !data.restriction(value, toValidate)) {
        console.error(`${prefix} ${key} invalid value: ${data.message}`);
        return false;
      }
      if (data.validValues && data.validValues.indexOf(value) === -1) {
        console.error(`${prefix} ${key} invalid value: must be among ${JSON.stringify(data.validValues)}, "${value}" provided`);
        return false;
      }
      if (data.children) {
        let valid = validateSpec(value, data.children, `[Validate ${key}]`);
        if (!valid) {
          return false;
        }
      }
      return true;
    });
    if (!skipMandatoryCheck) {
      results.push(...Object.keys(spec).map((key) => {
        let data = spec[key];
        if (typeof data === "string") {
          data = { type: data };
        }
        if (data.mandatory) {
          let mandatory = data.mandatory;
          if (typeof mandatory === "function") {
            mandatory = mandatory(toValidate);
          }
          if (mandatory && toValidate[key] === void 0) {
            console.error(`${prefix} Missing mandatory key "${key}"`);
            return false;
          }
        }
        return true;
      }));
    }
    return results.reduce((acc, current) => {
      return acc && current;
    }, true);
  }
  function validateFormat(format2) {
    return validateSpec(format2, validFormat, "[Validate format]");
  }
  function validateLanguage(language) {
    return validateSpec(language, validLanguage, "[Validate language]");
  }
  validating$1 = {
    validate,
    validateFormat,
    validateInput,
    validateLanguage
  };
  return validating$1;
}
function parsePrefix(string, result) {
  let match = string.match(/^{([^}]*)}/);
  if (match) {
    result.prefix = match[1];
    return string.slice(match[0].length);
  }
  return string;
}
function parsePostfix(string, result) {
  let match = string.match(/{([^}]*)}$/);
  if (match) {
    result.postfix = match[1];
    return string.slice(0, -match[0].length);
  }
  return string;
}
function parseOutput(string, result) {
  if (string.indexOf("$") !== -1) {
    result.output = "currency";
    return;
  }
  if (string.indexOf("%") !== -1) {
    result.output = "percent";
    return;
  }
  if (string.indexOf("bd") !== -1) {
    result.output = "byte";
    result.base = "general";
    return;
  }
  if (string.indexOf("b") !== -1) {
    result.output = "byte";
    result.base = "binary";
    return;
  }
  if (string.indexOf("d") !== -1) {
    result.output = "byte";
    result.base = "decimal";
    return;
  }
  if (string.indexOf(":") !== -1) {
    result.output = "time";
    return;
  }
  if (string.indexOf("o") !== -1) {
    result.output = "ordinal";
  }
}
function parseThousandSeparated(string, result) {
  if (string.indexOf(",") !== -1) {
    result.thousandSeparated = true;
  }
}
function parseSpaceSeparated(string, result) {
  if (string.indexOf(" ") !== -1) {
    result.spaceSeparated = true;
    result.spaceSeparatedCurrency = true;
    if (result.average || result.forceAverage) {
      result.spaceSeparatedAbbreviation = true;
    }
  }
}
function parseTotalLength(string, result) {
  let match = string.match(/[1-9]+[0-9]*/);
  if (match) {
    result.totalLength = +match[0];
  }
}
function parseCharacteristic(string, result) {
  let characteristic = string.split(".")[0];
  let match = characteristic.match(/0+/);
  if (match) {
    result.characteristic = match[0].length;
  }
}
function parseMantissa(string, result) {
  let mantissa = string.split(".")[1];
  if (mantissa) {
    let match = mantissa.match(/0+/);
    if (match) {
      result.mantissa = match[0].length;
    }
  }
}
function parseTrimMantissa(string, result) {
  const mantissa = string.split(".")[1];
  if (mantissa) {
    result.trimMantissa = mantissa.indexOf("[") !== -1;
  }
}
function parseAverage(string, result) {
  if (string.indexOf("a") !== -1) {
    result.average = true;
  }
}
function parseForceAverage(string, result) {
  if (string.indexOf("K") !== -1) {
    result.forceAverage = "thousand";
  } else if (string.indexOf("M") !== -1) {
    result.forceAverage = "million";
  } else if (string.indexOf("B") !== -1) {
    result.forceAverage = "billion";
  } else if (string.indexOf("T") !== -1) {
    result.forceAverage = "trillion";
  }
}
function parseOptionalMantissa(string, result) {
  if (string.match(/\[\.]/)) {
    result.optionalMantissa = true;
  } else if (string.match(/\./)) {
    result.optionalMantissa = false;
  }
}
function parseOptionalCharacteristic(string, result) {
  if (string.indexOf(".") !== -1) {
    let characteristic = string.split(".")[0];
    result.optionalCharacteristic = characteristic.indexOf("0") === -1;
  }
}
function parseNegative(string, result) {
  if (string.match(/^\+?\([^)]*\)$/)) {
    result.negative = "parenthesis";
  }
  if (string.match(/^\+?-/)) {
    result.negative = "sign";
  }
}
function parseForceSign(string, result) {
  if (string.match(/^\+/)) {
    result.forceSign = true;
  }
}
function parseFormat(string, result = {}) {
  if (typeof string !== "string") {
    return string;
  }
  string = parsePrefix(string, result);
  string = parsePostfix(string, result);
  parseOutput(string, result);
  parseTotalLength(string, result);
  parseCharacteristic(string, result);
  parseOptionalCharacteristic(string, result);
  parseAverage(string, result);
  parseForceAverage(string, result);
  parseMantissa(string, result);
  parseOptionalMantissa(string, result);
  parseTrimMantissa(string, result);
  parseThousandSeparated(string, result);
  parseSpaceSeparated(string, result);
  parseNegative(string, result);
  parseForceSign(string, result);
  return result;
}
var parsing$2 = {
  parseFormat
};
var globalState$2;
var hasRequiredGlobalState;
function requireGlobalState() {
  if (hasRequiredGlobalState)
    return globalState$2;
  hasRequiredGlobalState = 1;
  const enUS2 = requireEnUS();
  const validating2 = requireValidating();
  const parsing2 = parsing$2;
  let state = {};
  let currentLanguageTag = void 0;
  let languages = {};
  let zeroFormat = null;
  let globalDefaults = {};
  function chooseLanguage(tag) {
    currentLanguageTag = tag;
  }
  function currentLanguageData() {
    return languages[currentLanguageTag];
  }
  state.languages = () => Object.assign({}, languages);
  state.currentLanguage = () => currentLanguageTag;
  state.currentBytes = () => currentLanguageData().bytes || {};
  state.currentCurrency = () => currentLanguageData().currency;
  state.currentAbbreviations = () => currentLanguageData().abbreviations;
  state.currentDelimiters = () => currentLanguageData().delimiters;
  state.currentOrdinal = () => currentLanguageData().ordinal;
  state.currentDefaults = () => Object.assign({}, currentLanguageData().defaults, globalDefaults);
  state.currentOrdinalDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().ordinalFormat);
  state.currentByteDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().byteFormat);
  state.currentPercentageDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().percentageFormat);
  state.currentCurrencyDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().currencyFormat);
  state.currentTimeDefaultFormat = () => Object.assign({}, state.currentDefaults(), currentLanguageData().timeFormat);
  state.setDefaults = (format2) => {
    format2 = parsing2.parseFormat(format2);
    if (validating2.validateFormat(format2)) {
      globalDefaults = format2;
    }
  };
  state.getZeroFormat = () => zeroFormat;
  state.setZeroFormat = (string) => zeroFormat = typeof string === "string" ? string : null;
  state.hasZeroFormat = () => zeroFormat !== null;
  state.languageData = (tag) => {
    if (tag) {
      if (languages[tag]) {
        return languages[tag];
      }
      throw new Error(`Unknown tag "${tag}"`);
    }
    return currentLanguageData();
  };
  state.registerLanguage = (data, useLanguage = false) => {
    if (!validating2.validateLanguage(data)) {
      throw new Error("Invalid language data");
    }
    languages[data.languageTag] = data;
    if (useLanguage) {
      chooseLanguage(data.languageTag);
    }
  };
  state.setLanguage = (tag, fallbackTag = enUS2.languageTag) => {
    if (!languages[tag]) {
      let suffix = tag.split("-")[0];
      let matchingLanguageTag = Object.keys(languages).find((each) => {
        return each.split("-")[0] === suffix;
      });
      if (!languages[matchingLanguageTag]) {
        chooseLanguage(fallbackTag);
        return;
      }
      chooseLanguage(matchingLanguageTag);
      return;
    }
    chooseLanguage(tag);
  };
  state.registerLanguage(enUS2);
  currentLanguageTag = enUS2.languageTag;
  globalState$2 = state;
  return globalState$2;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
function loadLanguagesInNode(tags, numbro2) {
  tags.forEach((tag) => {
    let data = void 0;
    try {
      data = commonjsRequire(`../languages/${tag}`);
    } catch (e) {
      console.error(`Unable to load "${tag}". No matching language file found.`);
    }
    if (data) {
      numbro2.registerLanguage(data);
    }
  });
}
var loading = (numbro2) => ({
  loadLanguagesInNode: (tags) => loadLanguagesInNode(tags, numbro2)
});
var bignumber = { exports: {} };
(function(module) {
  (function(globalObject) {
    var BigNumber2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: " ",
        // non-breaking space
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
      function BigNumber3(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber3))
          return new BigNumber3(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          if (b == 10 && alphabetHasNormalDecimalDigits) {
            x = new BigNumber3(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber3.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber3.clone = clone;
      BigNumber3.ROUND_UP = 0;
      BigNumber3.ROUND_DOWN = 1;
      BigNumber3.ROUND_CEIL = 2;
      BigNumber3.ROUND_FLOOR = 3;
      BigNumber3.ROUND_HALF_UP = 4;
      BigNumber3.ROUND_HALF_DOWN = 5;
      BigNumber3.ROUND_HALF_EVEN = 6;
      BigNumber3.ROUND_HALF_CEIL = 7;
      BigNumber3.ROUND_HALF_FLOOR = 8;
      BigNumber3.EUCLID = 9;
      BigNumber3.config = BigNumber3.set = function(obj) {
        var p, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p = "RANGE")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p = "CRYPTO")) {
              v = obj[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p = "FORMAT")) {
              v = obj[p];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p = "ALPHABET")) {
              v = obj[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber3.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber3.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber3.maximum = BigNumber3.max = function() {
        return maxOrMin(arguments, -1);
      };
      BigNumber3.minimum = BigNumber3.min = function() {
        return maxOrMin(arguments, 1);
      };
      BigNumber3.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber3(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (; i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9e15) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 1e14);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (; i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 1e14);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k; ) {
              v = random53bitInt();
              if (v < 9e15)
                c[i++] = v % 1e14;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (; c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber3.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber3(args[0]);
        for (; i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j = 0; j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber3(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(
              toFixedPoint(coeffToString(x.c), x.e, "0"),
              10,
              baseOut,
              decimal
            );
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut; ++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length; !xc[--k]; )
              ;
            for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply2(x, k, base) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice(); i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract2(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber3(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                xc && xc[0] == 0 || !yc ? s * 0 : s / 0
              )
            );
          }
          q = new BigNumber3(s);
          qc = q.c = [];
          e = x.e - y.e;
          s = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0; yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply2(yc, n, base);
              xc = multiply2(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare2(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply2(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract2(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract2(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract2(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
              ;
            round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format2(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber3(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += "."; i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (; i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, n) {
        var k, y, i = 1, x = new BigNumber3(args[0]);
        for (; i < args.length; i++) {
          y = new BigNumber3(args[i]);
          if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
            x = y;
          }
        }
        return x;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (; !c[--j]; c.pop())
          ;
        for (j = c[0]; j >= 10; j /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base ? p1 : m;
              });
              if (b) {
                base = b;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s)
                return new BigNumber3(s, base);
            }
            if (BigNumber3.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
              ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = mathfloor(n / pows10[d - j - 1] % 10);
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (; xc.length <= ni; xc.push(0))
                    ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1; k >= 10; k /= 10, d++)
                  ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
              }
            }
            r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
            // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
            // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
            xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
            (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) {
              for (; ; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                    ;
                  j = xc[0] += k;
                  for (k = 1; j >= 10; j /= 10, k++)
                    ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length; xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber3(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P.comparedTo = function(y, b) {
        return compare(this, new BigNumber3(y, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber3(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (; v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber3(y, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber3(y, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber3(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m != null)
          m = new BigNumber3(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y = new BigNumber3(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
          return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s)
            return new BigNumber3(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp)
            x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k = 1 / k;
          return new BigNumber3(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber3(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y = new BigNumber3(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y = y.times(x);
            if (!y.c)
              break;
            if (k) {
              if (y.c.length > k)
                y.c.length = k;
            } else if (isModExp) {
              y = y.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k)
              x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp)
          return y;
        if (nIsNeg)
          y = ONE.div(y);
        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber3(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y, b) {
        return compare(this, new BigNumber3(y, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y, b) {
        return compare(this, new BigNumber3(y, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare(this, new BigNumber3(y, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y, b) {
        return compare(this, new BigNumber3(y, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare(this, new BigNumber3(y, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber3(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber3(NaN);
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y.s = -b, y) : new BigNumber3(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y.s = -b, y) : new BigNumber3(xc[0] ? x : (
              // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
              ROUNDING_MODE == 3 ? -0 : 0
            ));
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; t.push(0))
            ;
          t.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy) {
          t = xc;
          xc = yc;
          yc = t;
          y.s = -y.s;
        }
        b = (j = yc.length) - (i = xc.length);
        if (b > 0)
          for (; b--; xc[i++] = 0)
            ;
        b = BASE - 1;
        for (; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; xc[i] = b)
              ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y.s = ROUNDING_MODE == 3 ? -1 : 1;
          y.c = [y.e = 0];
          return y;
        }
        return normalise(y, xc, ye);
      };
      P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber3(y, b);
        if (!x.c || !y.s || y.c && !y.c[0]) {
          return new BigNumber3(NaN);
        } else if (!y.c || x.c && !x.c[0]) {
          return new BigNumber3(x);
        }
        if (MODULO_MODE == 9) {
          s = y.s;
          y.s = 1;
          q = div(x, y, 0, 3);
          y.s = s;
          q.s *= s;
        } else {
          q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        if (!y.c[0] && MODULO_MODE == 1)
          y.s = x.s;
        return y;
      };
      P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber3(y, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y.c = y.e = y.s = null;
          } else {
            y.s *= x.s;
            if (!xc || !yc) {
              y.c = y.e = null;
            } else {
              y.c = [0];
              y.e = 0;
            }
          }
          return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL) {
          zc = xc;
          xc = yc;
          yc = zc;
          i = xcL;
          xcL = ycL;
          ycL = i;
        }
        for (i = xcL + ycL, zc = []; i--; zc.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k; j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber3(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber3(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber3(NaN);
        if (a != b) {
          y.s = -b;
          return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber3(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y : new BigNumber3(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (; a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0) {
          t = yc;
          yc = xc;
          xc = t;
          b = a;
        }
        for (a = 0; b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber3(x), sd, rm);
        }
        if (!(c = x.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (; v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0]; v >= 10; v /= 10, n++)
            ;
        }
        if (sd && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
        if (s !== 1 || !c || !c[0]) {
          return new BigNumber3(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s = Math.sqrt(+valueOf(x));
        if (s == 0 || s == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber3(n);
        } else {
          r = new BigNumber3(s + "");
        }
        if (r.c[0]) {
          e = r.e;
          s = e + dp;
          if (s < 3)
            s = 0;
          for (; ; ) {
            t = r;
            r = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
              if (r.e < e)
                --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format2(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format2(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format3) {
        var str, x = this;
        if (format3 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format3 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format3 = dp;
            dp = rm = null;
          } else {
            format3 = FORMAT;
          }
        } else if (typeof format3 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format3);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2) {
            i = g1;
            g1 = g2;
            g2 = i;
            len -= i;
          }
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
            new RegExp("\\d{" + g2 + "}\\B", "g"),
            "$&" + (format3.fractionGroupSeparator || "")
          ) : fractionPart) : intPart;
        }
        return (format3.prefix || "") + str + (format3.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber3(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber3(x);
        d = new BigNumber3(ONE);
        n1 = d0 = new BigNumber3(ONE);
        d1 = n0 = new BigNumber3(ONE);
        s = coeffToString(xc);
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber3(s);
        n0.c[0] = 0;
        for (; ; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
        ) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format2(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) {
          if (s) {
            str = "Infinity";
            if (s < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10 && alphabetHasNormalDecimalDigits) {
            n = round(new BigNumber3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
          }
          if (s < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null)
        BigNumber3.set(configObject);
      return BigNumber3;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z, i = 1, j = a.length, r = a[0] + "";
      for (; i < j; ) {
        s = a[i++] + "";
        z = LOG_BASE - s.length;
        for (; z--; s = "0" + s)
          ;
        r += s;
      }
      for (j = r.length; r.charCodeAt(--j) === 48; )
        ;
      return r.slice(0, j + 1 || 1);
    }
    function compare(x, y) {
      var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!i || !j)
        return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b)
        return a ? b ? 0 : -j : i;
      if (i != j)
        return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc)
        return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b)
        return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0; i < j; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + "."; ++e; zs += z)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len; --e; zs += z)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber2 = clone();
    BigNumber2["default"] = BigNumber2.BigNumber = BigNumber2;
    if (module.exports) {
      module.exports = BigNumber2;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber2;
    }
  })(commonjsGlobal);
})(bignumber);
var bignumberExports = bignumber.exports;
var globalState$1 = requireGlobalState();
var validating = requireValidating();
var parsing$1 = parsing$2;
var BigNumber$1 = bignumberExports;
var powers = {
  trillion: Math.pow(10, 12),
  billion: Math.pow(10, 9),
  million: Math.pow(10, 6),
  thousand: Math.pow(10, 3)
};
var defaultOptions = {
  totalLength: 0,
  characteristic: 0,
  forceAverage: false,
  average: false,
  mantissa: -1,
  optionalMantissa: true,
  thousandSeparated: false,
  spaceSeparated: false,
  negative: "sign",
  forceSign: false,
  roundingFunction: Math.round,
  spaceSeparatedAbbreviation: false
};
var { binarySuffixes, decimalSuffixes } = globalState$1.currentBytes();
var bytes = {
  general: { scale: 1024, suffixes: decimalSuffixes, marker: "bd" },
  binary: { scale: 1024, suffixes: binarySuffixes, marker: "b" },
  decimal: { scale: 1e3, suffixes: decimalSuffixes, marker: "d" }
};
function format(instance, providedFormat = {}, numbro2) {
  if (typeof providedFormat === "string") {
    providedFormat = parsing$1.parseFormat(providedFormat);
  }
  let valid = validating.validateFormat(providedFormat);
  if (!valid) {
    return "ERROR: invalid format";
  }
  let prefix = providedFormat.prefix || "";
  let postfix = providedFormat.postfix || "";
  let output = formatNumbro(instance, providedFormat, numbro2);
  output = insertPrefix(output, prefix);
  output = insertPostfix(output, postfix);
  return output;
}
function formatNumbro(instance, providedFormat, numbro2) {
  switch (providedFormat.output) {
    case "currency": {
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentCurrencyDefaultFormat());
      return formatCurrency(instance, providedFormat, globalState$1);
    }
    case "percent": {
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentPercentageDefaultFormat());
      return formatPercentage(instance, providedFormat, globalState$1, numbro2);
    }
    case "byte":
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentByteDefaultFormat());
      return formatByte(instance, providedFormat, globalState$1, numbro2);
    case "time":
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentTimeDefaultFormat());
      return formatTime(instance);
    case "ordinal":
      providedFormat = formatOrDefault(providedFormat, globalState$1.currentOrdinalDefaultFormat());
      return formatOrdinal(instance, providedFormat, globalState$1);
    case "number":
    default:
      return formatNumber({
        instance,
        providedFormat,
        numbro: numbro2
      });
  }
}
function getDecimalByteUnit(instance) {
  let data = bytes.decimal;
  return getFormatByteUnits(instance._value, data.suffixes, data.scale).suffix;
}
function getBinaryByteUnit(instance) {
  let data = bytes.binary;
  return getFormatByteUnits(instance._value, data.suffixes, data.scale).suffix;
}
function getByteUnit(instance) {
  let data = bytes.general;
  return getFormatByteUnits(instance._value, data.suffixes, data.scale).suffix;
}
function getFormatByteUnits(value, suffixes, scale) {
  let suffix = suffixes[0];
  let abs = Math.abs(value);
  if (abs >= scale) {
    for (let power = 1; power < suffixes.length; ++power) {
      let min = Math.pow(scale, power);
      let max = Math.pow(scale, power + 1);
      if (abs >= min && abs < max) {
        suffix = suffixes[power];
        value = value / min;
        break;
      }
    }
    if (suffix === suffixes[0]) {
      value = value / Math.pow(scale, suffixes.length - 1);
      suffix = suffixes[suffixes.length - 1];
    }
  }
  return { value, suffix };
}
function formatByte(instance, providedFormat, state, numbro2) {
  let base = providedFormat.base || "binary";
  let options = Object.assign({}, defaultOptions, providedFormat);
  const { binarySuffixes: localBinarySuffixes, decimalSuffixes: localDecimalSuffixes } = state.currentBytes();
  const localBytes = {
    general: { scale: 1024, suffixes: localDecimalSuffixes || decimalSuffixes, marker: "bd" },
    binary: { scale: 1024, suffixes: localBinarySuffixes || binarySuffixes, marker: "b" },
    decimal: { scale: 1e3, suffixes: localDecimalSuffixes || decimalSuffixes, marker: "d" }
  };
  let baseInfo = localBytes[base];
  let { value, suffix } = getFormatByteUnits(instance._value, baseInfo.suffixes, baseInfo.scale);
  let output = formatNumber({
    instance: numbro2(value),
    providedFormat,
    state,
    defaults: state.currentByteDefaultFormat()
  });
  return `${output}${options.spaceSeparated ? " " : ""}${suffix}`;
}
function formatOrdinal(instance, providedFormat, state) {
  let ordinalFn = state.currentOrdinal();
  let options = Object.assign({}, defaultOptions, providedFormat);
  let output = formatNumber({
    instance,
    providedFormat,
    state
  });
  let ordinal = ordinalFn(instance._value);
  return `${output}${options.spaceSeparated ? " " : ""}${ordinal}`;
}
function formatTime(instance) {
  let hours = Math.floor(instance._value / 60 / 60);
  let minutes = Math.floor((instance._value - hours * 60 * 60) / 60);
  let seconds = Math.round(instance._value - hours * 60 * 60 - minutes * 60);
  return `${hours}:${minutes < 10 ? "0" : ""}${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
}
function formatPercentage(instance, providedFormat, state, numbro2) {
  let prefixSymbol = providedFormat.prefixSymbol;
  let output = formatNumber({
    instance: numbro2(instance._value * 100),
    providedFormat,
    state
  });
  let options = Object.assign({}, defaultOptions, providedFormat);
  if (prefixSymbol) {
    return `%${options.spaceSeparated ? " " : ""}${output}`;
  }
  return `${output}${options.spaceSeparated ? " " : ""}%`;
}
function formatCurrency(instance, providedFormat, state) {
  const currentCurrency = state.currentCurrency();
  let clonedFormat = Object.assign({}, providedFormat);
  let options = Object.assign({}, defaultOptions, clonedFormat);
  let decimalSeparator = void 0;
  let space = "";
  let average = !!options.totalLength || !!options.forceAverage || options.average;
  let position = clonedFormat.currencyPosition || currentCurrency.position;
  let symbol = clonedFormat.currencySymbol || currentCurrency.symbol;
  const spaceSeparatedCurrency = options.spaceSeparatedCurrency !== void 0 ? options.spaceSeparatedCurrency : options.spaceSeparated;
  if (clonedFormat.lowPrecision === void 0) {
    clonedFormat.lowPrecision = false;
  }
  if (spaceSeparatedCurrency) {
    space = " ";
  }
  if (position === "infix") {
    decimalSeparator = space + symbol + space;
  }
  let output = formatNumber({
    instance,
    providedFormat: clonedFormat,
    state,
    decimalSeparator
  });
  if (position === "prefix") {
    if (instance._value < 0 && options.negative === "sign") {
      output = `-${space}${symbol}${output.slice(1)}`;
    } else if (instance._value > 0 && options.forceSign) {
      output = `+${space}${symbol}${output.slice(1)}`;
    } else {
      output = symbol + space + output;
    }
  }
  if (!position || position === "postfix") {
    space = !options.spaceSeparatedAbbreviation && average ? "" : space;
    output = output + space + symbol;
  }
  return output;
}
function computeAverage({ value, forceAverage, lowPrecision = true, abbreviations, spaceSeparated = false, totalLength = 0, roundingFunction = Math.round }) {
  let abbreviation = "";
  let abs = Math.abs(value);
  let mantissaPrecision = -1;
  if (forceAverage && abbreviations[forceAverage] && powers[forceAverage]) {
    abbreviation = abbreviations[forceAverage];
    value = value / powers[forceAverage];
  } else {
    if (abs >= powers.trillion || lowPrecision && roundingFunction(abs / powers.trillion) === 1) {
      abbreviation = abbreviations.trillion;
      value = value / powers.trillion;
    } else if (abs < powers.trillion && abs >= powers.billion || lowPrecision && roundingFunction(abs / powers.billion) === 1) {
      abbreviation = abbreviations.billion;
      value = value / powers.billion;
    } else if (abs < powers.billion && abs >= powers.million || lowPrecision && roundingFunction(abs / powers.million) === 1) {
      abbreviation = abbreviations.million;
      value = value / powers.million;
    } else if (abs < powers.million && abs >= powers.thousand || lowPrecision && roundingFunction(abs / powers.thousand) === 1) {
      abbreviation = abbreviations.thousand;
      value = value / powers.thousand;
    }
  }
  let optionalSpace = spaceSeparated ? " " : "";
  if (abbreviation) {
    abbreviation = optionalSpace + abbreviation;
  }
  if (totalLength) {
    let isNegative = value < 0;
    let characteristic = value.toString().split(".")[0];
    let characteristicLength = isNegative ? characteristic.length - 1 : characteristic.length;
    mantissaPrecision = Math.max(totalLength - characteristicLength, 0);
  }
  return { value, abbreviation, mantissaPrecision };
}
function computeExponential({ value, characteristicPrecision }) {
  let [numberString, exponential] = value.toExponential().split("e");
  let number = +numberString;
  if (!characteristicPrecision) {
    return {
      value: number,
      abbreviation: `e${exponential}`
    };
  }
  let characteristicLength = 1;
  if (characteristicLength < characteristicPrecision) {
    number = number * Math.pow(10, characteristicPrecision - characteristicLength);
    exponential = +exponential - (characteristicPrecision - characteristicLength);
    exponential = exponential >= 0 ? `+${exponential}` : exponential;
  }
  return {
    value: number,
    abbreviation: `e${exponential}`
  };
}
function zeroes(number) {
  let result = "";
  for (let i = 0; i < number; i++) {
    result += "0";
  }
  return result;
}
function toFixedLarge(value, precision) {
  let result = value.toString();
  let [base, exp] = result.split("e");
  let [characteristic, mantissa = ""] = base.split(".");
  if (+exp > 0) {
    result = characteristic + mantissa + zeroes(exp - mantissa.length);
  } else {
    let prefix = ".";
    if (+characteristic < 0) {
      prefix = `-0${prefix}`;
    } else {
      prefix = `0${prefix}`;
    }
    let suffix = (zeroes(-exp - 1) + Math.abs(characteristic) + mantissa).substr(0, precision);
    if (suffix.length < precision) {
      suffix += zeroes(precision - suffix.length);
    }
    result = prefix + suffix;
  }
  if (+exp > 0 && precision > 0) {
    result += `.${zeroes(precision)}`;
  }
  return result;
}
function toFixed(value, precision, roundingFunction = Math.round) {
  if (value.toString().indexOf("e") !== -1) {
    return toFixedLarge(value, precision);
  }
  const n = new BigNumber$1(roundingFunction(+`${value}e+${precision}`) / Math.pow(10, precision));
  return n.toFixed(precision);
}
function setMantissaPrecision(output, value, optionalMantissa, precision, trim, roundingFunction) {
  if (precision === -1) {
    return output;
  }
  let result = toFixed(value, precision, roundingFunction);
  let [currentCharacteristic, currentMantissa = ""] = result.toString().split(".");
  if (currentMantissa.match(/^0+$/) && (optionalMantissa || trim)) {
    return currentCharacteristic;
  }
  let hasTrailingZeroes = currentMantissa.match(/0+$/);
  if (trim && hasTrailingZeroes) {
    return `${currentCharacteristic}.${currentMantissa.toString().slice(0, hasTrailingZeroes.index)}`;
  }
  return result.toString();
}
function setCharacteristicPrecision(output, value, optionalCharacteristic, precision) {
  let result = output;
  let [currentCharacteristic, currentMantissa] = result.toString().split(".");
  if (currentCharacteristic.match(/^-?0$/) && optionalCharacteristic) {
    if (!currentMantissa) {
      return currentCharacteristic.replace("0", "");
    }
    return `${currentCharacteristic.replace("0", "")}.${currentMantissa}`;
  }
  const hasNegativeSign = value < 0 && currentCharacteristic.indexOf("-") === 0;
  if (hasNegativeSign) {
    currentCharacteristic = currentCharacteristic.slice(1);
    result = result.slice(1);
  }
  if (currentCharacteristic.length < precision) {
    let missingZeros = precision - currentCharacteristic.length;
    for (let i = 0; i < missingZeros; i++) {
      result = `0${result}`;
    }
  }
  if (hasNegativeSign) {
    result = `-${result}`;
  }
  return result.toString();
}
function indexesOfGroupSpaces(totalLength, groupSize) {
  let result = [];
  let counter = 0;
  for (let i = totalLength; i > 0; i--) {
    if (counter === groupSize) {
      result.unshift(i);
      counter = 0;
    }
    counter++;
  }
  return result;
}
function replaceDelimiters(output, value, thousandSeparated, state, decimalSeparator) {
  let delimiters = state.currentDelimiters();
  let thousandSeparator = delimiters.thousands;
  decimalSeparator = decimalSeparator || delimiters.decimal;
  let thousandsSize = delimiters.thousandsSize || 3;
  let result = output.toString();
  let characteristic = result.split(".")[0];
  let mantissa = result.split(".")[1];
  const hasNegativeSign = value < 0 && characteristic.indexOf("-") === 0;
  if (thousandSeparated) {
    if (hasNegativeSign) {
      characteristic = characteristic.slice(1);
    }
    let indexesToInsertThousandDelimiters = indexesOfGroupSpaces(characteristic.length, thousandsSize);
    indexesToInsertThousandDelimiters.forEach((position, index) => {
      characteristic = characteristic.slice(0, position + index) + thousandSeparator + characteristic.slice(position + index);
    });
    if (hasNegativeSign) {
      characteristic = `-${characteristic}`;
    }
  }
  if (!mantissa) {
    result = characteristic;
  } else {
    result = characteristic + decimalSeparator + mantissa;
  }
  return result;
}
function insertAbbreviation(output, abbreviation) {
  return output + abbreviation;
}
function insertSign(output, value, negative) {
  if (value === 0) {
    return output;
  }
  if (+output === 0) {
    return output.replace("-", "");
  }
  if (value > 0) {
    return `+${output}`;
  }
  if (negative === "sign") {
    return output;
  }
  return `(${output.replace("-", "")})`;
}
function insertPrefix(output, prefix) {
  return prefix + output;
}
function insertPostfix(output, postfix) {
  return output + postfix;
}
function formatNumber({ instance, providedFormat, state = globalState$1, decimalSeparator, defaults = state.currentDefaults() }) {
  let value = instance._value;
  if (value === 0 && state.hasZeroFormat()) {
    return state.getZeroFormat();
  }
  if (!isFinite(value)) {
    return value.toString();
  }
  let options = Object.assign({}, defaultOptions, defaults, providedFormat);
  let totalLength = options.totalLength;
  let characteristicPrecision = totalLength ? 0 : options.characteristic;
  let optionalCharacteristic = options.optionalCharacteristic;
  let forceAverage = options.forceAverage;
  let lowPrecision = options.lowPrecision;
  let average = !!totalLength || !!forceAverage || options.average;
  let mantissaPrecision = totalLength ? -1 : average && providedFormat.mantissa === void 0 ? 0 : options.mantissa;
  let optionalMantissa = totalLength ? false : providedFormat.optionalMantissa === void 0 ? mantissaPrecision === -1 : options.optionalMantissa;
  let trimMantissa = options.trimMantissa;
  let thousandSeparated = options.thousandSeparated;
  let spaceSeparated = options.spaceSeparated;
  let negative = options.negative;
  let forceSign = options.forceSign;
  let exponential = options.exponential;
  let roundingFunction = options.roundingFunction;
  let abbreviation = "";
  if (average) {
    let data = computeAverage({
      value,
      forceAverage,
      lowPrecision,
      abbreviations: state.currentAbbreviations(),
      spaceSeparated,
      roundingFunction,
      totalLength
    });
    value = data.value;
    abbreviation += data.abbreviation;
    if (totalLength) {
      mantissaPrecision = data.mantissaPrecision;
    }
  }
  if (exponential) {
    let data = computeExponential({
      value,
      characteristicPrecision
    });
    value = data.value;
    abbreviation = data.abbreviation + abbreviation;
  }
  let output = setMantissaPrecision(value.toString(), value, optionalMantissa, mantissaPrecision, trimMantissa, roundingFunction);
  output = setCharacteristicPrecision(output, value, optionalCharacteristic, characteristicPrecision);
  output = replaceDelimiters(output, value, thousandSeparated, state, decimalSeparator);
  if (average || exponential) {
    output = insertAbbreviation(output, abbreviation);
  }
  if (forceSign || value < 0) {
    output = insertSign(output, value, negative);
  }
  return output;
}
function formatOrDefault(providedFormat, defaultFormat) {
  if (!providedFormat) {
    return defaultFormat;
  }
  let keys = Object.keys(providedFormat);
  if (keys.length === 1 && keys[0] === "output") {
    return defaultFormat;
  }
  return providedFormat;
}
var formatting = (numbro2) => ({
  format: (...args) => format(...args, numbro2),
  getByteUnit: (...args) => getByteUnit(...args, numbro2),
  getBinaryByteUnit: (...args) => getBinaryByteUnit(...args, numbro2),
  getDecimalByteUnit: (...args) => getDecimalByteUnit(...args, numbro2),
  formatOrDefault
});
var BigNumber = bignumberExports;
function add(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.plus(otherValue).toNumber();
  return n;
}
function subtract(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.minus(otherValue).toNumber();
  return n;
}
function multiply(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.times(otherValue).toNumber();
  return n;
}
function divide(n, other, numbro2) {
  let value = new BigNumber(n._value);
  let otherValue = other;
  if (numbro2.isNumbro(other)) {
    otherValue = other._value;
  }
  otherValue = new BigNumber(otherValue);
  n._value = value.dividedBy(otherValue).toNumber();
  return n;
}
function set(n, other, numbro2) {
  let value = other;
  if (numbro2.isNumbro(other)) {
    value = other._value;
  }
  n._value = value;
  return n;
}
function difference(n, other, numbro2) {
  let clone = numbro2(n._value);
  subtract(clone, other, numbro2);
  return Math.abs(clone._value);
}
var manipulating = (numbro2) => ({
  add: (n, other) => add(n, other, numbro2),
  subtract: (n, other) => subtract(n, other, numbro2),
  multiply: (n, other) => multiply(n, other, numbro2),
  divide: (n, other) => divide(n, other, numbro2),
  set: (n, other) => set(n, other, numbro2),
  difference: (n, other) => difference(n, other, numbro2),
  BigNumber
});
var VERSION = "2.5.0";
var globalState = requireGlobalState();
var validator = requireValidating();
var loader = loading(numbro);
var unformatter = requireUnformatting();
var formatter = formatting(numbro);
var manipulate = manipulating(numbro);
var parsing = parsing$2;
var Numbro = class {
  constructor(number) {
    this._value = number;
  }
  clone() {
    return numbro(this._value);
  }
  format(format2 = {}) {
    return formatter.format(this, format2);
  }
  formatCurrency(format2) {
    if (typeof format2 === "string") {
      format2 = parsing.parseFormat(format2);
    }
    format2 = formatter.formatOrDefault(format2, globalState.currentCurrencyDefaultFormat());
    format2.output = "currency";
    return formatter.format(this, format2);
  }
  formatTime(format2 = {}) {
    format2.output = "time";
    return formatter.format(this, format2);
  }
  binaryByteUnits() {
    return formatter.getBinaryByteUnit(this);
  }
  decimalByteUnits() {
    return formatter.getDecimalByteUnit(this);
  }
  byteUnits() {
    return formatter.getByteUnit(this);
  }
  difference(other) {
    return manipulate.difference(this, other);
  }
  add(other) {
    return manipulate.add(this, other);
  }
  subtract(other) {
    return manipulate.subtract(this, other);
  }
  multiply(other) {
    return manipulate.multiply(this, other);
  }
  divide(other) {
    return manipulate.divide(this, other);
  }
  set(input) {
    return manipulate.set(this, normalizeInput(input));
  }
  value() {
    return this._value;
  }
  valueOf() {
    return this._value;
  }
};
function normalizeInput(input) {
  let result = input;
  if (numbro.isNumbro(input)) {
    result = input._value;
  } else if (typeof input === "string") {
    result = numbro.unformat(input);
  } else if (isNaN(input)) {
    result = NaN;
  }
  return result;
}
function numbro(input) {
  return new Numbro(normalizeInput(input));
}
numbro.version = VERSION;
numbro.isNumbro = function(object) {
  return object instanceof Numbro;
};
numbro.language = globalState.currentLanguage;
numbro.registerLanguage = globalState.registerLanguage;
numbro.setLanguage = globalState.setLanguage;
numbro.languages = globalState.languages;
numbro.languageData = globalState.languageData;
numbro.zeroFormat = globalState.setZeroFormat;
numbro.defaultFormat = globalState.currentDefaults;
numbro.setDefaults = globalState.setDefaults;
numbro.defaultCurrencyFormat = globalState.currentCurrencyDefaultFormat;
numbro.validate = validator.validate;
numbro.loadLanguagesInNode = loader.loadLanguagesInNode;
numbro.unformat = unformatter.unformat;
numbro.BigNumber = manipulate.BigNumber;
var numbro_1 = numbro;
var numbro$1 = getDefaultExportFromCjs(numbro_1);
export {
  numbro$1 as default
};
/*! Bundled license information:

numbro/dist/es/numbro.js:
  (*!
   * Copyright (c) 2017 Benjamin Van Ryseghem<benjamin@vanryseghem.com>
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)
*/
//# sourceMappingURL=numbro.js.map
